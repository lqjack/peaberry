Index: test/com/googlecode/guice/OSGiContainerTest.java
===================================================================
--- test/com/googlecode/guice/OSGiContainerTest.java	(revision 0)
+++ test/com/googlecode/guice/OSGiContainerTest.java	(revision 0)
@@ -0,0 +1,128 @@
+/**
+ * Copyright (C) 2009 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.googlecode.guice;
+
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.Iterator;
+import java.util.Properties;
+
+import javax.imageio.spi.ServiceRegistry;
+
+import junit.framework.TestCase;
+
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.launch.Framework;
+import org.osgi.framework.launch.FrameworkFactory;
+
+import aQute.bnd.main.bnd;
+
+import com.googlecode.guice.bundle.OSGiTestActivator;
+
+/**
+ * Run various tests inside one or more OSGi containers.
+ * 
+ * @author mcculls@gmail.com (Stuart McCulloch)
+ */
+public class OSGiContainerTest
+    extends TestCase {
+
+  // build properties passed from Ant
+  static final String VERSION = System.getProperty("version", "snapshot");
+  static final String BUILD_DIR = System.getProperty("build.dir", "build");
+  static final String LIB_DIR = System.getProperty("lib.dir", "lib");
+
+  static final String BUILD_DIST_DIR = BUILD_DIR + "/dist";
+  static final String BUILD_TEST_DIR = BUILD_DIR + "/test";
+
+  static final String GUICE_JAR = BUILD_DIST_DIR + "/guice-" + VERSION + ".jar";
+
+  // dynamically build test bundles
+  @Override protected void setUp()
+      throws Exception {
+
+    // verify properties
+    assertTrue(new File(BUILD_DIR).isDirectory());
+    assertTrue(new File(LIB_DIR).isDirectory());
+    assertTrue(new File(GUICE_JAR).isFile());
+
+    Properties instructions = new Properties();
+
+    // javax.inject is an API bundle --> export the full API
+    instructions.setProperty("Export-Package", "javax.inject.*");
+    buildBundle("javax.inject", instructions, LIB_DIR + "/javax.inject.jar");
+    instructions.clear();
+
+    // aopalliance is an API bundle --> export the full API
+    instructions.setProperty("Export-Package", "org.aopalliance.*");
+    buildBundle("aopalliance", instructions, LIB_DIR + "/aopalliance.jar");
+    instructions.clear();
+
+    // strict imports to make sure test bundle only has access to these packages
+    instructions.setProperty("Import-Package", "org.osgi.framework,org.aopalliance.intercept,"
+        + "com.google.inject(|.binder|.matcher|.name);version=\"[1,2)\"");
+
+    // test bundle should only contain the local test classes, nothing else
+    instructions.setProperty("Bundle-Activator", OSGiTestActivator.class.getName());
+    instructions.setProperty("Private-Package", OSGiTestActivator.class.getPackage().getName());
+    buildBundle("osgitests", instructions, BUILD_TEST_DIR);
+    instructions.clear();
+  }
+
+  // build an OSGi bundle at runtime
+  private static void buildBundle(String name, Properties instructions, String classpath)
+      throws IOException {
+
+    // write BND instructions to temporary test directory
+    String bndFileName = BUILD_TEST_DIR + '/' + name + ".bnd";
+    OutputStream os = new BufferedOutputStream(new FileOutputStream(bndFileName));
+    instructions.store(os, "BND instructions");
+    os.close();
+
+    // assemble bundle, use -failok switch to avoid early exit
+    bnd.main(new String[]{"-failok", "build", "-classpath", classpath, bndFileName});
+  }
+
+  public void testGuiceWorksInOSGiContainer()
+      throws Throwable {
+
+    // ask framework to clear cache on startup
+    Properties properties = new Properties();
+    properties.setProperty("org.osgi.framework.storage", BUILD_TEST_DIR + "/bundle.cache");
+    properties.setProperty("org.osgi.framework.storage.clean", "onFirstInit");
+
+    // test each available OSGi framework in turn
+    Iterator<FrameworkFactory> f = ServiceRegistry.lookupProviders(FrameworkFactory.class);
+    while (f.hasNext()) {
+      Framework framework = f.next().newFramework(properties);
+
+      framework.start();
+      BundleContext systemContext = framework.getBundleContext();
+
+      // load all the necessary bundles and start the OSGi test bundle
+      systemContext.installBundle("reference:file:" + BUILD_TEST_DIR + "/aopalliance.jar");
+      systemContext.installBundle("reference:file:" + BUILD_TEST_DIR + "/javax.inject.jar");
+      systemContext.installBundle("reference:file:" + GUICE_JAR);
+      systemContext.installBundle("reference:file:" + BUILD_TEST_DIR + "/osgitests.jar").start();
+
+      framework.stop();
+    }
+  }
+}
\ No newline at end of file

Property changes on: test/com/googlecode/guice/OSGiContainerTest.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: test/com/googlecode/guice/bundle/OSGiTestActivator.java
===================================================================
--- test/com/googlecode/guice/bundle/OSGiTestActivator.java	(revision 0)
+++ test/com/googlecode/guice/bundle/OSGiTestActivator.java	(revision 0)
@@ -0,0 +1,505 @@
+/**
+ * Copyright (C) 2009 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.googlecode.guice.bundle;
+
+import static com.google.inject.name.Names.named;
+
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.Random;
+
+import org.aopalliance.intercept.MethodInterceptor;
+import org.aopalliance.intercept.MethodInvocation;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleActivator;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.BundleException;
+
+import com.google.inject.AbstractModule;
+import com.google.inject.Guice;
+import com.google.inject.Inject;
+import com.google.inject.Injector;
+import com.google.inject.Key;
+import com.google.inject.matcher.AbstractMatcher;
+
+/**
+ * Test Guice from inside an OSGi bundle activator.
+ * 
+ * @author mcculls@gmail.com (Stuart McCulloch)
+ */
+@SuppressWarnings("unused") public class OSGiTestActivator
+    implements BundleActivator {
+
+  // varying visibilities to test our code-generation support
+
+  public static class _ {}
+
+  public interface A {}
+
+  protected interface B {}
+
+  interface C {}
+
+  private interface D {}
+
+  public static class AA
+      implements A {
+
+    public AA() {}
+
+    @Inject public void setA(_ _) {}
+
+    @Inject protected void setB(_ _) {}
+
+    @Inject void setC(_ _) {}
+
+    @Inject private void setD(_ _) {}
+
+    @Inject public _ a;
+
+    @Inject protected _ b;
+
+    @Inject _ c;
+
+    @Inject private _ d;
+  }
+
+  protected static class AB
+      implements A {
+
+    public AB() {}
+
+    @Inject public void setA(_ _) {}
+
+    @Inject protected void setB(_ _) {}
+
+    @Inject void setC(_ _) {}
+
+    @Inject private void setD(_ _) {}
+
+    @Inject public _ a;
+
+    @Inject protected _ b;
+
+    @Inject _ c;
+
+    @Inject private _ d;
+  }
+
+  static class AC
+      implements A {
+
+    public AC() {}
+
+    @Inject public void setA(_ _) {}
+
+    @Inject protected void setB(_ _) {}
+
+    @Inject void setC(_ _) {}
+
+    @Inject private void setD(_ _) {}
+
+    @Inject public _ a;
+
+    @Inject protected _ b;
+
+    @Inject _ c;
+
+    @Inject private _ d;
+  }
+
+  private static class AD
+      implements A {
+
+    public AD() {}
+
+    @Inject public void setA(_ _) {}
+
+    @Inject protected void setB(_ _) {}
+
+    @Inject void setC(_ _) {}
+
+    @Inject private void setD(_ _) {}
+
+    @Inject public _ a;
+
+    @Inject protected _ b;
+
+    @Inject _ c;
+
+    @Inject private _ d;
+  }
+
+  public static class BA
+      implements B {
+
+    protected BA() {}
+
+    @Inject public void setA(_ _) {}
+
+    @Inject protected void setB(_ _) {}
+
+    @Inject void setC(_ _) {}
+
+    @Inject private void setD(_ _) {}
+
+    @Inject public _ a;
+
+    @Inject protected _ b;
+
+    @Inject _ c;
+
+    @Inject private _ d;
+  }
+
+  protected static class BB
+      implements B {
+
+    protected BB() {}
+
+    @Inject public void setA(_ _) {}
+
+    @Inject protected void setB(_ _) {}
+
+    @Inject void setC(_ _) {}
+
+    @Inject private void setD(_ _) {}
+
+    @Inject public _ a;
+
+    @Inject protected _ b;
+
+    @Inject _ c;
+
+    @Inject private _ d;
+  }
+
+  static class BC
+      implements B {
+
+    protected BC() {}
+
+    @Inject public void setA(_ _) {}
+
+    @Inject protected void setB(_ _) {}
+
+    @Inject void setC(_ _) {}
+
+    @Inject private void setD(_ _) {}
+
+    @Inject public _ a;
+
+    @Inject protected _ b;
+
+    @Inject _ c;
+
+    @Inject private _ d;
+  }
+
+  private static class BD
+      implements B {
+
+    protected BD() {}
+
+    @Inject public void setA(_ _) {}
+
+    @Inject protected void setB(_ _) {}
+
+    @Inject void setC(_ _) {}
+
+    @Inject private void setD(_ _) {}
+
+    @Inject public _ a;
+
+    @Inject protected _ b;
+
+    @Inject _ c;
+
+    @Inject private _ d;
+  }
+
+  public static class CA
+      implements C {
+
+    CA() {}
+
+    @Inject public void setA(_ _) {}
+
+    @Inject protected void setB(_ _) {}
+
+    @Inject void setC(_ _) {}
+
+    @Inject private void setD(_ _) {}
+
+    @Inject public _ a;
+
+    @Inject protected _ b;
+
+    @Inject _ c;
+
+    @Inject private _ d;
+  }
+
+  protected static class CB
+      implements C {
+
+    CB() {}
+
+    @Inject public void setA(_ _) {}
+
+    @Inject protected void setB(_ _) {}
+
+    @Inject void setC(_ _) {}
+
+    @Inject private void setD(_ _) {}
+
+    @Inject public _ a;
+
+    @Inject protected _ b;
+
+    @Inject _ c;
+
+    @Inject private _ d;
+  }
+
+  static class CC
+      implements C {
+
+    CC() {}
+
+    @Inject public void setA(_ _) {}
+
+    @Inject protected void setB(_ _) {}
+
+    @Inject void setC(_ _) {}
+
+    @Inject private void setD(_ _) {}
+
+    @Inject public _ a;
+
+    @Inject protected _ b;
+
+    @Inject _ c;
+
+    @Inject private _ d;
+  }
+
+  private static class CD
+      implements C {
+
+    CD() {}
+
+    @Inject public void setA(_ _) {}
+
+    @Inject protected void setB(_ _) {}
+
+    @Inject void setC(_ _) {}
+
+    @Inject private void setD(_ _) {}
+
+    @Inject public _ a;
+
+    @Inject protected _ b;
+
+    @Inject _ c;
+
+    @Inject private _ d;
+  }
+
+  public static class DA
+      implements D {
+
+    @Inject private DA() {}
+
+    @Inject public void setA(_ _) {}
+
+    @Inject protected void setB(_ _) {}
+
+    @Inject void setC(_ _) {}
+
+    @Inject private void setD(_ _) {}
+
+    @Inject public _ a;
+
+    @Inject protected _ b;
+
+    @Inject _ c;
+
+    @Inject private _ d;
+  }
+
+  protected static class DB
+      implements D {
+
+    @Inject private DB() {}
+
+    @Inject public void setA(_ _) {}
+
+    @Inject protected void setB(_ _) {}
+
+    @Inject void setC(_ _) {}
+
+    @Inject private void setD(_ _) {}
+
+    @Inject public _ a;
+
+    @Inject protected _ b;
+
+    @Inject _ c;
+
+    @Inject private _ d;
+  }
+
+  static class DC
+      implements D {
+
+    @Inject private DC() {}
+
+    @Inject public void setA(_ _) {}
+
+    @Inject protected void setB(_ _) {}
+
+    @Inject void setC(_ _) {}
+
+    @Inject private void setD(_ _) {}
+
+    @Inject public _ a;
+
+    @Inject protected _ b;
+
+    @Inject _ c;
+
+    @Inject private _ d;
+  }
+
+  private static class DD
+      implements D {
+
+    private DD() {}
+
+    @Inject public void setA(_ _) {}
+
+    @Inject protected void setB(_ _) {}
+
+    @Inject void setC(_ _) {}
+
+    @Inject private void setD(_ _) {}
+
+    @Inject public _ a;
+
+    @Inject protected _ b;
+
+    @Inject _ c;
+
+    @Inject private _ d;
+  }
+
+  enum Visibility {
+    PUBLIC, PROTECTED, PACKAGE_PRIVATE, PRIVATE
+  }
+
+  static final Class<?>[] TEST_CLAZZES = {A.class, B.class, C.class, D.class};
+
+  // registers all the class combinations
+  static class TestModule
+      extends AbstractModule {
+
+    final Bundle bundle;
+
+    TestModule(Bundle bundle) {
+      this.bundle = bundle;
+    }
+
+    @Override @SuppressWarnings("unchecked") protected void configure() {
+      for (Class<?> api : TEST_CLAZZES) {
+        for (Visibility visibility : Visibility.values()) {
+          try {
+
+            // this registers: A + PUBLIC -> AA, A + PROTECTED -> AB, etc...
+            String suffix = TEST_CLAZZES[visibility.ordinal()].getSimpleName();
+            Class imp = bundle.loadClass(api.getName() + suffix);
+            bind(api).annotatedWith(named(visibility.name())).to(imp);
+
+          } catch (ClassNotFoundException e) {
+            throw new RuntimeException("Unable to load test class", e);
+          }
+        }
+      }
+    }
+  }
+
+  // applies method-interception to classes with enough visibility
+  static class InterceptorModule
+      extends AbstractModule {
+    @Override protected void configure() {
+      bindInterceptor(new AbstractMatcher<Class<?>>() {
+        public boolean matches(Class<?> clazz) {
+          try {
+
+            // the class and constructor must be visible
+            int clazzModifiers = clazz.getModifiers();
+            int ctorModifiers = clazz.getConstructor().getModifiers();
+            return (clazzModifiers & (Modifier.PUBLIC | Modifier.PROTECTED)) != 0
+                && (ctorModifiers & (Modifier.PUBLIC | Modifier.PROTECTED)) != 0;
+
+          } catch (NoSuchMethodException e) {
+            return false;
+          }
+        }
+      }, new AbstractMatcher<Method>() {
+        public boolean matches(Method method) {
+
+          // the intercepted method must also be visible
+          int methodModifiers = method.getModifiers();
+          return (methodModifiers & (Modifier.PUBLIC | Modifier.PROTECTED)) != 0;
+
+        }
+      }, new MethodInterceptor() {
+        public Object invoke(MethodInvocation mi)
+            throws Throwable {
+
+          return mi.proceed();
+        }
+      });
+    }
+  }
+
+  // called from OSGi when bundle starts
+  public void start(BundleContext context)
+      throws BundleException {
+
+    final Bundle bundle = context.getBundle();
+
+    Injector injector = Guice.createInjector(new TestModule(bundle));
+    Injector aopInjector = Guice.createInjector(new TestModule(bundle), new InterceptorModule());
+
+    // test code-generation support
+    for (Class<?> api : TEST_CLAZZES) {
+      for (Visibility vis : Visibility.values()) {
+        injector.getInstance(Key.get(api, named(vis.name())));
+        aopInjector.getInstance(Key.get(api, named(vis.name())));
+      }
+    }
+
+    // test injection of system class (issue 343)
+    injector.getInstance(Random.class);
+    aopInjector.getInstance(Random.class);
+  }
+
+  // called from OSGi when bundle stops
+  public void stop(BundleContext context) {}
+}
\ No newline at end of file

Property changes on: test/com/googlecode/guice/bundle/OSGiTestActivator.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: test/com/google/inject/AllTests.java
===================================================================
--- test/com/google/inject/AllTests.java	(revision 1121)
+++ test/com/google/inject/AllTests.java	(working copy)
@@ -135,6 +135,7 @@
     suite.addTestSuite(MethodInterceptionTest.class);
     suite.addTestSuite(com.googlecode.guice.BytecodeGenTest.class);
     suite.addTest(com.googlecode.guice.StrictContainerTestSuite.suite());
+    suite.addTestSuite(com.googlecode.guice.OSGiContainerTest.class);
     /*end[AOP]*/
 
     // googlecode.guice
Index: build.xml
===================================================================
--- build.xml	(revision 1121)
+++ build.xml	(working copy)
@@ -90,10 +90,15 @@
         <pathelement location="lib/build/easymock.jar"/>
         <pathelement location="lib/javax.inject.jar"/>
         <pathelement location="lib/build/javax.inject-tck.jar"/>
+        <pathelement location="lib/build/bnd-0.0.372.jar"/>
+        <pathelement location="lib/build/felix-2.0.1.jar"/>
       </classpath>
       <arg value="com.google.inject.AllTests"/>    
       <syspropertyset>
         <propertyref name="guice.custom.loader"/>
+        <propertyref name="version"/>
+        <propertyref name="build.dir"/>
+        <propertyref name="lib.dir"/>
       </syspropertyset>
     </java>
   </target>
Index: lib/build/bnd-0.0.305.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: lib/build/bnd-0.0.372.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: lib/build/bnd-0.0.372.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: lib/build/felix-2.0.1.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: lib/build/felix-2.0.1.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

