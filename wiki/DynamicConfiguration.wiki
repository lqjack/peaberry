#summary Discussion about injecting dynamic configuration.
#labels Phase-Design

= Introduction =

Configuration is a crosscutting concern. This means that a single body of configuration items is typically needed at points all over the code. Some items are shared, others are used in one spot only. As such configuration is an ideal candidate for dependency injection. Guice has facilities that allow the user to take a property file and inject it's elements all over the code at @Named("property.key") injection points. 

This is all perfectly adequate for code that is configured once at startup. When the code heeds to be reconfigured at runtime however this mechanism is no longer sufficient. A dynamic configuration framework must support a much richer set of requirements than a static one.

= Requirements =

Here is a list of possible requirements. We can use these as means to compare suggested solutions.

  * Fine configuration granularity
Just like with static config `@Named` items dynamic config item must be individually injectable. Each class should be able to cherry-pick only the items it needs.

  * Fine update granularity
We would like the impact of dynamic configuration update to be localized to the places in the program, which consume the relevant configuration items. We would like to leave it to the developer to choose how much of the accumulated runtime state must be destroyed as a result of configuration update.

  * Atomic update
Often items from the same configuration are related. This relation must be preserved when sapping a new configuration in place of an old one. E.g. we can have a `min` and `max` values with the invariant that `min < max`.

  * Dynamic update
Often the configured code regularly reads a particular config item value as it goes about it's business. If that value changes between two loops the configured code must pick up the new value the next time it reads the config item. We want to pick up the new set of values on the fly: i.e do not restart some piece of the program and re-inject config information.

  * Static update
Some times the configured code must react to the change of a config item on the spot. An example for this is an accept loop that is reconfigured to listen on another port. It is very desirable that as soon as the config changes the old server socket gets closed and the accept loop is restarted on a socket opened on the new port. Here some part of the program must be stopped, new config information must be injected and the part be started again.

 * Simplicity
Use current all the standard injection techniques: inject to setters, constructors, fields. It would be best if we can use the `@Named` parameters and let Guice deal with the configuration.

 * Safety
Synchronization swaps happen concurrently to the application control flow. It would be best if we can hide this complexity from the developers. They should not care about synchronization or atomicity of config swaps.
 
= Suggested Designs =

== Config as composite value ==

The idea is to use some of Clojure's principles: the entire config is a single composite immutable value. The various config elements are accessed by dereferencing this value and than browsing through it's guts. When a config swap comes the entire value is swapped in one atomic step. The developers know to access configuration information in two steps: pop the config, and than browse it's content. This is the only way to compensate for the lack of transactions: i.e. the app can't have any other way to look at several related config items at once.

Evaluation:
 * `(-)` Fine configuration granularity
 * `(+)` Fine update granularity
 * `(+)` Atomic update
 * `(+)` Dynamic update
 * `(-)` Static update
 * `(-)` Simplicity
 * `(+)` Safety

== Configuration as bundle lifecycle ==

Here we treat the config update as a bundle lifecycle event and restart the bundle. Than we can pass the config items at good old `@Named` injection points because upon update we stop everything, drop the bundle internals, create new ones against the the new config, and start them. Restarting the bundle will destroy any runtime state it has accumulated during it's operation. This means that bundles that accumulate lot's of runtime state will need to either live with it's loss or store/load it as part of their lifecycle. I am not sure how much of an issue this really is. Normally we use stateless bundles or if they are stateful the load/store is a normal requirement. Probably this is a blocker issue for transient state that can't be restored like communication sessions.

Evaluation:
 * `(+)` Fine configuration granularity
 * `(-)` Fine update granularity
 * `(+)` Atomic update
 * `(-)` Dynamic update
 * `(+)` Static update
 * `(+)` Simplicity
 * `(+)` Safety

== Config as component lifecycle ==

Here we fold the re-configuration into the future lifecycle extension. A config update is a lifecycle event for all components that consume config items. We have two options here:

 * Use `Injector.injectMembers()` to re-inject the configuration to setter methods. We choose setter methods because they can be called many times during the lifecycle of the object. We can control the atomicity of the swap with multi-parameter setters. E.g. `setBounds(int min, int max)`. If an object is 'transient' and does not care about config updates it can take config items via the constructor.

 * We use start/stop methods to restart the object. This time all config items are passed as parameters to the `start()` method. Again we have atomicity by using many parameters. This essentially mimics the bundle restart approach but at a finer granularity.

Evaluation:
 * `(+)` Fine configuration granularity
 * `(+)` Fine update granularity
 * `(+)` Atomic update
 * `(-)` Dynamic update
 * `(+)` Static update
 * `(+)` Simplicity
 * `(-)` Safety