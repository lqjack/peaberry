#summary Discussion about injecting dynamic configuration.
#labels Phase-Design

= Introduction =

Configuration is a crosscutting concern. This means that a single body of configuration items is typically needed at points all over the code. Some items are shared, others are used in one spot only. As such configuration is an ideal candidate for dependency injection. Guice has facilities that allow the user to take a property file and inject it's elements all over the code at @Named("property.key") injection points. 

This is all perfectly adequate for code that is configured once at startup. When the code heeds to be reconfigured at runtime however this mechanism is no longer sufficient. A dynamic configuration framework must support a much richer set of requirements than a static one.

= Requirements =

Here is a list of possible requirements. We can use these as means to compare suggested solutions.

  * Fine granularity
Just like with static config `@Named` items dynamic config item must be individually injectable. Each class should be able to cherry-pick only the items it needs.

  * Atomicity
Often items from the same configuration are related. This relation must be preserved when sapping a new configuration in place of an old one. E.g. we can have a `min` and `max` values with the invariant that `min < max`.

  * Dynamic update
Often the configured code regularly reads a particular config item value as it goes about it's business. If that value changes between two loops the configured code must pick up the new value the next time it reads the config item. We want to pick up the new set of values on the fly: i.e do not restart some piece of the program and re-inject config information.

  * Static update
Some times the configured code must react to the change of a config item on the spot. An example for this is an accept loop that is reconfigured to listen on another port. It is very desirable that as soon as the config changes the old server socket gets closed and the accept loop is restarted on a socket opened on the new port. Here some part of the program must be stopped, new config information must be injected and the part be started again.

 * Simplicity
Use current all the standard injection techniques: inject to setters, constructors, fields. It would be best if we can use the `@Named` parameters and let Guice deal with the configuration.

 * Safety
Synchronization swaps happen concurrently to the application control flow. It would be best if we can hide this complexity from the developers. They should not care about synchronization or atomicity of config swaps.
 
 * Generality
We aim to support the ConfigAdmin service under OSGi. However it would be nice if we can support dynamic configuration updates in other environments.

= Suggested Designs =

== Config as composite value ==

The idea is to use some of Clojure's principles: the entire config is a single composite immutable value. The various config elements are accessed by dereferencing this value and than browsing through it's guts. When a config swap comes the entire value is swapped in one atomic step. The developers know to access configuration information in two steps: pop the config, and than browse it's content. This is the only way to compensate for the lack of transactions: i.e. the app can't have any other way to look at several related config items at once.

Evaluation:
 * `(-)` Fine granularity
 * `(+)` Atomicity
 * `(+)` Dynamic update
 * `(-)` Static update
 * `(-)` Simplicity
 * `(+)` Safety

== Config as bundle lifecycle ==

Another design is to treat the config update as a bundle lifecycle event and restart the bundle. Than we can pass the config items at good old @Named injection points because upon update we stop everything, drop the bundle internals, create new ones against the the new config, and start them.

Evaluation:
 * `(+)` Fine granularity
 * `(+)` Atomicity
 * `(-)` Dynamic update
 * `(+)` Static update
 * `(+)` Simplicity
 * `(+)` Safety

== Config as component lifecycle ==

Here we fold the re-configuration into the future lifecycle extension. A config update is a lifecycle event for all components that consume config items. We have two options here:

 * Use `Injector.injectMembers()` to re-inject the configuration to setter methods. We choose setter methods because they can be called many times during the lifecycle of the object. We can control the atomicity of the swap with multi-parameter setters. E.g. `setBounds(int min, int max)`. If an object is 'transient' and does not care about config updates it can take config items via the constructor.

 * We use start/stop methods to restart the object. This time all config items are passed as parameters to the `start()` method. Again we have atomicity by using many parameters. This essentially mimics the bundle restart approach but at a finer granularity.

Evaluation:
 * `(+)` Fine granularity
 * `(-)` Atomicity
 * `(-)` Dynamic update
 * `(+)` Static update
 * `(+)` Simplicity
 * `(-)` Safety