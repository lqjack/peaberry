Index: src/com/google/inject/internal/Errors.java
===================================================================
--- src/com/google/inject/internal/Errors.java	(revision 1115)
+++ src/com/google/inject/internal/Errors.java	(working copy)
@@ -125,6 +125,10 @@
     return addMessage("No implementation for %s was bound.", key);
   }
 
+  public Errors missingTypeConverter(TypeLiteral<?> type) {
+    return addMessage("No type converter for %s was found.", type);
+  }
+
   public Errors converterReturnedNull(String stringValue, Object source,
       TypeLiteral<?> type, MatcherAndConverter matchingConverter) {
     return addMessage("Received null converting '%s' (bound at %s) to %s%n"
Index: src/com/google/inject/internal/InjectorImpl.java
===================================================================
--- src/com/google/inject/internal/InjectorImpl.java	(revision 1115)
+++ src/com/google/inject/internal/InjectorImpl.java	(working copy)
@@ -284,6 +284,15 @@
 
     // Find a matching type converter.
     TypeLiteral<T> type = key.getTypeLiteral();
+    T converted = convertConstantString(stringValue, type, errors, source);
+    if (converted != null) {
+      return new ConvertedConstantBindingImpl<T>(this, key, converted, stringBinding);
+    }
+    return null;
+  }
+
+  private <T> T convertConstantString(String stringValue, TypeLiteral<T> type, Errors errors, Object source)
+      throws ErrorsException {
     MatcherAndConverter matchingConverter = state.getConverter(stringValue, type, errors, source);
 
     if (matchingConverter == null) {
@@ -306,7 +315,7 @@
             .toException();
       }
 
-      return new ConvertedConstantBindingImpl<T>(this, key, converted, stringBinding);
+      return converted;
     } catch (ErrorsException e) {
       throw e;
     } catch (RuntimeException e) {
@@ -821,4 +830,19 @@
         .toString();
   }
 
+  public <T> T convertConstant(String value, TypeLiteral<T> toType) {
+    if (toType.getRawType().equals(String.class)) {
+      return (T)value;
+    }
+    Errors errors = new Errors();
+    try {
+      T converted = convertConstantString(value, toType, errors, SourceProvider.UNKNOWN_SOURCE);
+      if (null == converted) {
+        errors.missingTypeConverter( toType ).throwConfigurationExceptionIfErrorsExist();
+      }
+      return converted;
+    } catch (ErrorsException e) {
+      throw new ConfigurationException(errors.merge(e.getErrors()).getMessages());
+    }
+  }
 }
Index: src/com/google/inject/internal/InjectorBuilder.java
===================================================================
--- src/com/google/inject/internal/InjectorBuilder.java	(revision 1115)
+++ src/com/google/inject/internal/InjectorBuilder.java	(working copy)
@@ -295,5 +295,9 @@
       throw new UnsupportedOperationException(
         "Injector.getInstance(Class<T>) is not supported in Stage.TOOL");
     }
+    public <T> T convertConstant(String value, TypeLiteral<T> toType) {
+      throw new UnsupportedOperationException(
+        "Injector.convertConstant(String, TypeLiteral<T>) is not supported in Stage.TOOL");
+    }
   }
 }
Index: src/com/google/inject/Injector.java
===================================================================
--- src/com/google/inject/Injector.java	(revision 1115)
+++ src/com/google/inject/Injector.java	(working copy)
@@ -232,4 +232,17 @@
    * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
    */
   Map<Class<? extends Annotation>, Scope> getScopeBindings();
+
+  /**
+   * Converts a string constant to an instance of the given type {@code T}.
+   *
+   * @param value string constant
+   * @param toType target type
+   * 
+   * @throws ConfigurationException if this injector cannot find a suitable type converter.
+   * @throws ProvisionException if there was a runtime failure while converting the constant.
+   * 
+   * @since 2.1
+   */
+  <T> T convertConstant(String value, TypeLiteral<T> toType);
 }
